## 1、线程的使用

### 1.1 为什么是多线程而不是多进程

线程是操作系统调度的最小单位

同一进程中的多个线程可以**共享**相同的**全局变量**，这样访问资源非常快，系统开销小

如果是多个进程，对于不同进程中的通讯，还需要IPC（进程间通讯来解决）

### 1.2 线程的标识pthread_t

> 本文档仅讨论POSIX接口中的多线程

线程通过tid来唯一标识，本质是pthread_t类型的变量，并且仅在其所属的进程上下文中才有意义。

可以通过pthread_self()函数来获取当前线程的tid：

```c
#include <pthread.h>
pthread_t tid = pthread_self();//获取主线程的 tid 号
```

编写多线程的程序时，使用gcc编译时必须指定pthread库：

```sh
gcc -o my_multi_thread my_multi_thread.c -lpthread
```

### 1.3 线程的创建

#### 1.3.1**创建线程的函数：**

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
```

**pthread_t *thread:**创建线程成功之后，通过指针返回线程tid

**const pthread_attr_t *attr:**指定线程的属性，一般填NULL，即使用默认属性

**void * (*start_routine) (void *):**新线程执行的函数，返回指针类型，传入一个指针入参

**void *arg:**传给新线程的入参（指针类型）

**返回：**

成功：0

失败：其他



```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

void *my_thread(void *arg)
{
    print("the new thread tid is : %lu\n",(unsigned long)pthread_self());
}
int main()
{
    int ret;
    pthread_t tid;
    ret = pthread_create(&tid,NULL,my_thread, NULL);
    if(ret !=0)
    {
        perror("create thread error");
        return -1;
    }
    printf("main thread: %lu, new thread: %lu\n",pthread_self(),tid);
    sleep(1);//休眠1s，以免进程结束，新线程没能正常运行
    return;
}
```



#### 1.3.2 新建线程的特点

1、主线程伴随的进程结束，新线程也会立即结束

2、单一进程下面的线程之间**执行顺序是随机竞争的**

### 1.4 向线程传入参数

#### 1.4.1 通过指针传递变量（地址传递）

通过指针传递变量有个特点：原调用处变量值变化时，新线程也能拿到变化后的值

示例代码如下：

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

void *my_func(void *arg)
{
    printf("the a value: %d",*(int *)arg);//转换指针指向的类型之后再取值
}
int main()
{
    int a =50;
    int ret;
    pthread_t tid;
    ret = pthread_create(&tid,NULL,my_thread, (void *)&a);
    if(ret !=0)
    {
        perror("create thread error");
        return -1;
    }
    sleep(1);
    return -1;
    
}
```

#### 1.4.2 直接传递变量（值的传递）

直接传递变量的话，当main主线程中变量的值变化时，新线程并不能拿到变化后的变量：

> 注意：将int类型强制转换成void * 前，需要先转换成long，避免出错：
>
> `(void *)(long)a)`

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

void *my_func(void *arg)
{
    printf("the a value: %d",(int)(long)arg);//转换指针指向的类型之后再取值
}
int main()
{
    int a =50;
    int ret;
    pthread_t tid;
    ret = pthread_create(&tid,NULL,my_thread, (void *)(long)a);
    if(ret !=0)
    {
        perror("create thread error");
        return -1;
    }
    sleep(1);
    return -1;
    
}
```

#### 1.4.3 传递多个变量

当需要给新线程传递多个变量时，我们需要使用结构体来传递

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

struct test_t
{
    int id;
    char name[32];
    float mark;
}

void *my_func(void *arg)
{
    struct test_t *func_struct = (struct test_t *)arg;//其实不太理解这里面又创建了一个指针变量存放传入的指针 是为什么
    printf("id: %d, name: %s, mark:%.2f\n",func_struct->id,func_struct->name,func_struct->mark);//转换指针指向的类型之后再取值
}
int main()
{
    int a =50;
    int ret;
    pthread_t tid;
    
    struct test_t my_struct;
    my_struct.id = 10000;
    strcpy(my_struct.name,"LiuAo");
    my_struct.mark = 94.6;
    ret = pthread_create(&tid,NULL,my_thread, (void *)&my_struct);
    if(ret !=0)
    {
        perror("create thread error");
        return -1;
    }
    sleep(1);
    return -1;
    
}
```

### 1.5 线程的退出与回收

> 线程退出有三种方式：进程结束会退出掉其下的所有线程、线程主动退出、线程被动退出

#### 1.5.1 线程主动退出

调用该函数退出当前线程

```c
#include <pthread.h>
void pthread_exit(void *retval);
```

**void *retval：**传递给主线程的返回值（主线程通过pthread_join or pthread_tryjoin_np来回收该线程并获得retval）

不想传返回值就将其置为`NULL`

> 注意：当变量从线程传出的时候（*retval），需要加 static 修饰，对生命周期做出延续，否则无法传出正确的变量值。  

**返回：**

成功：0

#### 1.5.2 线程被动退出

在线程1中调用，退出线程2

```c
#include <pthread.h>
int pthread_cancel(pthread_t thread);
```

**pthread_t thread：**被退出线程的tid（貌似就不能给主线程返回值了）

**返回：**

成功：0

#### 1.5.3 线程资源的回收（阻塞方式）

默认为阻塞状态，知道成功回收线程后返回

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
```

**pthread_t thread：**要回收线程的tid

void  **retval：被回收线程的返回值（因为线程返回的是指针，所以这里要存放指针的指针）

**返回：**

成功：0

#### 1.5.4 线程资源的回收（非阻塞方式）

不阻塞，成功就返回0

```c
#include <pthread.h>
int pthread_tryjoin_np(pthread_t thread, void **retval);
```

#### 1.5.5 例子

例子1：

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

void *fun1(void *arg)
{
    static int tmp = 0;//必须为static,否则主线程无法正确获得返回
    tmp = *(int *)arg;
    tmp += 100;
    printf("the new thread get tmp become: %d\n",tmp);
    pthread_exit((void *)&tmp);
}

int main()
{
    pthread_t my_thread;
    void *tmp;
    int a =50;
    int ret = pthread_create(&my_thread, NULL,fun1,(void *)&a);
    if (ret!=0)
    {
        perror("create thread error");
        return -1;
    }
    pthread_join(my_thread,&tmp);/*阻塞方式就不需要判断返回值了，程序执行下去就一定成功*/
    printf("my thread is over, the return is :%d\n",*(int*)tmp);
    return 0;
}
```

