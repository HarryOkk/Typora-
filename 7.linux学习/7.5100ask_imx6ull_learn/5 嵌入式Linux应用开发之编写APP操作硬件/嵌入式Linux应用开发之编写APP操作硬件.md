## 1、头文件的作用

### 1.1 头文件“.h”：

**头文件在编译时起作用**

好的头文件包含：函数的声明+注释，别人在使用你写的函数时，只需要看头文件就够了

知道函数的参数、返回值类型（给编译器看的）

以及使用方式（给函数的使用人看的）

> 比如同一个公司的两个人在合作开发时，使用头文件进行交流就可以了

### 1.2 程序中头文件的索引方式

```c
#include "hello.h"//在程序文件当前目录里面找
#include <stdio.h>//在gcc的系统头文件目录中查找
```

#### 常见问题

##### 1、使用<>引用头文件，编译时提示找不到：

要么将头文件放入到gcc的系统目录

要么在使用gcc命令时，使用`-I <dir>`选项指定头文件的索引目录（gcc中找不到时在此目录中查找）

```shell
gcc -I ./ -o main main.c
```

**如何找到系统目录在哪？打印gcc编译器的系统目录命令：**

```shell
# ‘gcc’可以更换为交叉编译工具
echo "main(){}" | gcc -E -v -
```

##### 2、工作实战

在公司项目中，可能会持续扩充.c/.h文件

一般在项目当前目录下建立一个include文件夹，所有的头文件都放在这里面

编译的使时候就可以使用-I选项指定这个文件夹 

```shell
gcc -I include -o main main.c
```

## 2、库的作用

### 2.1 库文件的作用

**库文件在链接的时候起作用**

库文件包含函数的定义，可以替代.c源码。

在不想让对方拿到你们的源码时，可以用库(比如和外部公司合作时，很多时候不可以暴露代码)。

****

库包含动态库（.so）和静态库（.o），工作中**常使用动态库**：

- 动态库在程序运行的时候链接，所以需要把动态库放到板子上
- 静态库在编译链接的时候直接链接，可以不放到板子上，但是得到的可执行程序文件会比较大

### 2.2 库文件的索引方式

同样可以使用`echo "main(){}" | gcc -E -v -` 来打印出gcc工具的默认库文件路径

### 2.3 外部库的编译步骤

1、需要将.so/.o文件放入gcc工具目录(比如是libhello.so)

> 动态库的编译方式：
>
> <img src="../../../6.图片/image-20241006154254649.png" alt="image-20241006154254649" style="zoom:50%;" />
>
> 注意 选项`-c -o`不可颠倒

2、gcc编译：

使用`-l`选项指定库，库的名字去掉libhello.so前面的lib和后面的.so，

```shell
gcc -o main main.c -lhello
```

3、可以指定库的存储路径

编译的时候使用`-L <dir>`选项：

```shell
gcc -o main main.c -lhello -L ./
```

## 3、头文件和库文件的总结

### 3.1 编译

程序代码在编译时，需要指定头文件，这时候是头文件在起作用

### 3.2 链接

程序代码在链接的时候，需要拿到外部函数的定义，这时候，是库文件在起作用

### 3.3 运行

程序在运行时，有两个要素：可执行程序文件+动态库

#### 3.3.1 动态库的使用

在交叉编译环境制作好动态库之后，如何保证程序和动态库正常运行？

1、将制作好的动态库（交叉编译）放入开发板系统目录

系统目录：

- /lib
- /usr/lib 
- ...

2、应用程序编译时，gcc命令应使用`-l<name>`来指定动态库

3、如果开发板系统目录没有动态库，也可以在开发板上指定动态库目录

通过修改开发板环境变量的方式：

```shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:<your_lib_dir> 
```

## 4、Makefile的学习与使用

韦东山老师弄了一套通用Makefile，只要学会使用这套通用的Makefile即可

### 4.1 通用Makefile的路径：

E:\weidongshanLinux\01_all_series_quickstart\04_嵌入式Linux应用开发基础知识\source\05_general_Makefile

### 4.2 通用Makefile的使用

详情见“说明”

