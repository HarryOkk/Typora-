# 1.进程的基本概念

## 1.1 Linux进程简介

### 1.1.1**进程的定义：在自身的虚拟地址空间运行的一个单独的程序。**

> 进程的四要素：
>
> 1.一段供进程执行的程序；
>
> 2.进程专用的系统堆栈空间，也叫进程空间；
>
> 3.进程控制块，Liunx的具体实现为task_struct；
>
> 4.独立的存储空间。

### 1.1.2 Linux系统所有进程都是由进程号为1的init进程复制而来

### 1.1.3 进程树

根为init，其他进程都是fork来的。

### 1.1.4 进程的分类

**交互进程**：由shell启动的进程，分为前台进程和后台进程。

**批处理进程：**bash脚本，是一个进程序列。

**监控进程（守护进程）：**Linux系统启动时启动的进程，并在后台运行。

## 1.2 进程与作业（task）

**作业**：包含一个或多个进程，是当前正在执行的进程。

```shell
nroff -man ps.1 | grep kill |more
```

**作业控制：**控制正在运行的进程的行为。比如挂起、重新执行进程；管道、重定向等shell命令。属于shell的特性。（内核会保存挂起进程的上下文）

## 1.3 进程标识

**PCB：**Process Control Block，进程控制块。进程创建时由内核分配。

> **PCB应包含的一些信息：**
>
> **1.进程标识符（Process ID）**：每个进程唯一拥有。非负整数。
>
> 2.进程当前状态：就绪、等待、执行。内核包含就绪进程丢列、等待进程队列（等待打印机队列、等待磁盘IO队列等）；
>
> 3.进程相应的程序和数据地址；
>
> 4.进程资源清单：拥有的IO设备，打开的文件列表等。
>
> 5.进程优先级：可由用户指定和系统设置。
>
> 6.CPU现场保护区：挂起进程的CPU执行上下文。
>
> 7.进程同步与通信机制：信号量等。
>
> 8.进程所在队列的PCB链接字：指向当前进程队列下一进程的指针（链表结构）
>
> 9.进程其他信息：进程记账信息、进程占用CPU的时间。

---

> **专用进程及其进程ID**：
>
> PID=0：调度进程（swapper交换进程），内核的一部分。
>
> PID=1：init进程。程序文件在/sbin/init（老UINX在/etc/init）。

---

> **进程组和会话：**
>
> 进程组（process group）：一个或多个进程合起来。
>
> 会话（session）：一个或多个进程组。
>
> 用于对进程批量操作：比如对进程组发送信号相当于对其中每个进程都发送信号。

---

> ```shell
> #罗列当前系统正在运行的所有进程
> ps
> #列出每一个进程的详细信息
> ps -aux
> ```

### 1.1 获取当前进程的PID

```c
#include <sys/types.h>
#include <unistd.h>
//pid_t其实和int类型完全兼容
pid_t getpid(void);
```

# 2. 进程控制的相关函数

## 2.1 fork和vfork函数

#### 2.1.1 fork函数

**系统调用fork：用于派生进程**

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
/*
1.返回：父进程中返回子进程ID；子进程返回0；出错返回-1。
2.子进程从父进程得到数据段和堆栈段的拷贝，并分配新的内存；只读的代码段，通常为共享内存形式；
3.用途：进程复制自身，父子进程执行不同的代码段；进程想执行另外一个进程。
4.fork返回后，子进程和父进程都从调用fork函数的下一条语句开始执行。所以代码可以在fork后面使用if测试来区分父进程代码和子进程代码。
*/
```

**fork创建子进程的代码编写方式：**

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main(void)
{
    int count = 0;
    pid_t pid;
    pid = fork;
    if(pid<0)
    {
        printf("error in fork!");
        exit(1);
    }
    else if(pid==0)
    {
        printf("I am the child process! My PID is %d\n", getpid());
        exit(1);
    }
    else
        printf("I am the father process! My PID is %d\n",getpid());
    return 0;
}

/*
父子进程的区别：
1.fork返回的pid不同；
2.进程PID也不同。
3.fork函数真的很奇妙，一次调用可以由两个返回值！！！！
4.fork返回值=负数（出错）的可能：系统进程数已经达到上限（errno=EAGAIN）；系统内存不足（errno=ENOMEM）
*/
```

**errno说明：**

> 1. Linux下的一个宏定义常量；
> 2. Linux C-API函数发生异常时，其值不同；
> 3. 使用其需要`#include <errno.h>`；
> 4. 相关的声明在路径/usr/include/asm/errno.h中。
> 5. 查看该值可以推测出错的原因，有的时候可以解决很多莫名奇妙的问题。

#### 2.1.2 vfork函数

**函数特点：**

```c
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);

/*
与fork的关系：
1.返回类型与fork()函数相同；
2.fork会拷贝数据段和堆栈段，而vfork不会开呗父进程的数据段，vfork执行之后，exec或exit执行之前，与父进程共享数据段；
3.fork执行后，父子进程没有次序之分；而vfork执行之后，父进程挂起，子进程先运行，待子进程调用了exec或exit之后，父子进程的执行次序才无限制；
4.实际其创建的不是进程，而是线程（因与父进程共享数据段，故缺少四要素之一：独立的内存资源）；
5.由于堆栈段是用于存放函数调用和全局变量、静态变量的，父子进程不共享。
*/
```

**例子：**

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
int main(void)
{
    int count = 1,i;
    int pid;
    printf("创建进程前，count=%d",count);
    if(pid = vfork() < 0)
        printf("vfork error!");
    else if (pid=0)
    {
        for(i=0;i<10;i++)
        {
            printf("son is running! i=%d",i);
        }
        printf("this is vfork son! count=%d,my PID = %d",++count,getpid());
    	exit(1); 
    }   
    else
         printf("SON is over ,this is vfork son! count=%d,my PID = %d",count,getpid());
    return 0;
}

/*
从打印结果可以看出，子进程修改的count值，在父进程空间中也生效，说明vfork得到的父子进程共享数据段！
*/
```

